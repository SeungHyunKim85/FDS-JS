# 5월 8일 내용 정리

## 5월 8일 러버덕
- 명시적/암묵적 타입변환
- 단축평가(&&, ||)
- 자바스크립트에서의 객체란 무엇인가
- 자바스크립트 객체 프로퍼티 여러 접근 방법

## 원시 값과 객체의 비교
- 객체 뮤터블 변경 가능한 값
- 원시 타입 임뮤터블 변경 불가능한 값
- 원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이다. 이에 비해 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.
- 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다. 
- 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(Pass by reference)라 한다.

## 임뮤터블은 무엇인가? 변수와 헷갈리면 안된다.
- 변수 자체가 값은 아니다. 재할당이 자유롭다. 값을 가질 수 있는 가능성이 있으면 변수.
- 상수. 변수의 상대적인 개념. 재할당이 불가능하다
- 통상 첫번쨰 할당은 초기화 라고 한다.

- 변수는 조심해서 다뤄야
- 객체도 원시값처럼 쓴다. 요즘
- 원시값처럼 새로 만들어서 재할당
- 원시값은 데이터가 작다 객체값은 데이터가 크다.
- 클래스 기반 언어
- 자바스크립트 – 프로퍼티를 동적 생성
- 객체는 뮤터블 밸류로 만들 수 밖에 없었다(컴퓨터 성능상 한계)
- 이뮤터블 뮤터블
- 값에 의한 전달(Pass by value)
- 가비지 콜렉터
- 메모리 완전 확보
- Memory Leak

- 객체는 이름으로 찾는다. 배열은 순서로 찾는다.
- 실무에서는 객체와 배열을 섞어쓴다

- 객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달된다
- 참조에 의한 전달(Pass by reference)라 한다.

- 두개의 식별자가 하나의 객체를 공유하고 있는 상황 var copy = person;

- 퀴즈
- 1 객체 비교 2 원시값 비교

## 선언, 정의. 함수에서는 함수 정의라고 하자.
- 함수 정의 Function definition
- 함수 호출
- 함수 할당 패스 바이 밸류로 Pass by value
- 매개변수와 인수의 차이 잘 알아야.
- 매개변수(parameter) 인수(argument)

- 함수의 사용 이유 – 코드의 재사용이라는 측면에서 매우 유용
- 유지보수(Maintanance) – 실수를 줄이고 품질도 좋아지고 돈도 적게 든다

- 함수 리터럴 – 함수 객체를 만드는 표현 방식

- 함수 선언문 – 가장 일반적으로 사용된다. 함수 호이스팅
- 함수 표현식 – 변수 선언문 + 할당문. 변수 호이스팅
- function 생성자 함수 – 잘 사용하지 않는다
- 화살표함수 ES6 에서 등장 =>

- 함수 선언문 
- 함수 표현식
- 일반 객체와 함수 객체의 차이? 함수 객체는 호출할 수 있다
- [[Call]] 
- argument , parameter 구분해서 사용하도록

- 인수가 잘못들어 왔을떄 어떻게 하고 싶은가?

- 매개변수의 개수

## 외부 상태의 변경과 함수형 프로그래밍
- 반환문
- 반환문은 두가지 역할을 한다. 
- 첫번째, 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다. 따라서 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다.
- 두번째, 반환문은 return 키워드 뒤에 지정한 값을 반환한다. return 키워드 뒤에 반환값을 명시적으로 지정하지 않으면 undefined가 반환된다.
- 즉시실행함수
- 함수의 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수(IIFE, Immediately Invoke Function Expression)라고 한다
- 함수명이 있는 기명 즉시 실행 함수도 사용할 수 있다. 하지만 함수명은 함수 몸체에서만 참조할 수 있는 식별자이므로 즉시 실행 함수를 다시 호출할 수는 없다.

- (function () { //...}());
- 가장 심플하고 일반적인 스타일
- 인위적인 스코프를 만들고 싶을 때. 클로저를 만들고 싶을 떄 사용

- 재귀 함수
- 주의해서 사용해야 함.
- 재귀 함수는 반복문을 사용하는 것 보다 재귀 함수를 사용하는 것이 보다 직관적으로 이해하기 쉬울 때에만 한정적으로 사용하는 것이 바람직하다

- 중첩 함수
- 일반적으로 중첩 함수는 자신을 포함하는 외부 함수(outer function)를 돕는 헬퍼 함수(helper function)의 역할을 한다.
- 중첩은 부자 관계를 갖는다. 스코프 체인. 

## 스코프
- 식별자가 다른 코드에 의해서 참조 될 수 있느냐 없느냐 의 유효범위
- 식별자 – 값 
- 중첩관계
- 중첩된 함수 내부에서 선언된 변수
- shadowing
- var 로 선언한 변수는 스코프가 안만들어 진다
- 함수 만이 스코프가 만들어 진다
- 그 문맥이 스코프
- 상위 스코프에서는 하위 스코프를 못본다
- 하위 스코프에서는 상위 스코프를 볼 수 있다.

- 변수는 자신이 선언된 위치에 의해 자신이 유효한 범위, 즉 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정된다. 이 범위를 스코프(Scope, 유효범위)라 한다. 

- 스코프란 자바스크립트 엔진이 참조할 변수를 검색할 때 사용하는 규칙이라고 할 수 있다
- 지금까지 스코프에서 식별자를 찾은 것
- 스코프: 식별자를 찾는 규칙
- 중첩이 있어야 스코프 체인이 만들어지는 것.
- 토크나이징, 렉싱
- 함수도 식별자다. 함수를 가리키고 있는 것도 식별자다.
- 선언하면 식별자를 떠올려야.
- 선언하면 식별자가 새긴다.

- 함수 레벨 스코프

- 렉시컬 스코프 – 클로저에서 집중적으로
- 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.

- 자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라 상위 스코프를 결정한다

- 암묵적 전역 변수
