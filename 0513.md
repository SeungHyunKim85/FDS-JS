# 05월 13일 내용정리

##

## 러버덕
- 전역변수의 문제점
- 암묵적 결합
- 긴 생명 주기
- 스코프 체인 상에서 종점에 존재
- 네임 스페이스 오염
- var 문제점 
- 변수 중복 선언 허용
- 함수 레벨 스코프
- 변수 호이스팅
- var let const 특징

- 이전 러버덕
- 변수:
- '한 값'을 담기위한 메모리 공간에 붙인 '이름' 또는 메모리공간 '그자체'
- -> 여러개 값 저장하고 싶으면 객체나 배열사용
- 변수 선언
- 변수명을 등록하여, 자바스크립트 엔진에게 변수존재를 알리고 관리하게하는 것
- var a; 처럼 '변수 선언' 정의와 차이는
- 값을 '할당하지 않은것'이나, 자바스크립트에서는 undefined로 자동할당된다는 것이 특징
- 할당
- a=10; 처럼 변수에 값을 '저장'
- 식별자
- 변수,함수처럼 다른것과 구별하기 위해 자바스크립트엔진에게 알리는 행위
- 정의
- 변수에 값을 할당하여 변수의 실체를 명확히 하는 것
- var a = 10; 처럼
- 변수선언 및 10으로 할당(정의)
- 타언어에서는 선언과 정확하게 구분되나 자바스크립트는 선언시 자동 undefiend로 할당되므로 선언시 정의 된다고 생각
- 브라우저 렌더링 과정 : 사용자가 www.naver.com 이라고 치고 엔터쳤을시 가정
- 유저인터페이스에서 www.naver. 라고 받아서, 브라우저 엔진에서 서버에 요청, 렌더링 엔진이 파싱하여 그려준다.
- html 코드를 그리다가 script태그를 만나면 그리기를 멈추고 자바스크립트 엔진으로 넘어가고  AST를 그린후 다시 렌더링 엔진 작동
- https://d2.naver.com/helloworld/59361참고
- 변수 호이스팅 
- console.log(x);
- var x = 5 처럼, 변수 (선언+할당)보다 참조가 먼저 발생하면 , reference에러가 발생해야 하지만, 
- 런타임보다 먼저 파싱타임에서 선언문들을 '호이스팅 =선언문 최상단 으로 끌어오는 것같이'동작하여 참조 에러가 아닌 undefined값이 출력되는것
- 함수 호이스팅:
- 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅(Function Hoisting)이라 한다
```
console.log(add(2, 5)); 
function add(x, y) {
  return x + y;
}
```
- 처럼 변수 호이스팅과 마찬가지로 함수 선언문보다 함수 호출문이 먼저 발생했음에도 에러가 발생하지 않고, 정의가 되었다고 나오는 행위
- 값이란
- 더이상 평가할 수 없는 표현식
- 표현식이란
- 50+50같이 하나의 '값'으로 평가될 '문'
- 문이란
- 하나 이상의 표현식과 키워드의 조합으로 구성된 자바스크립트 엔진에게 내리는 명령
- 프로그래밍이란 결국 '문'들의 집합
- 데이터 타입의 분류(원시타입, 참조타입)
- 변경가능하냐 불가능하냐가 구분점
- 숫자(number) 타입: 숫자 (정수, 실수)
- 문자열(string) 타입: 문자열
- 불리언(boolean) 타입: 논리적 참(true)과 거짓(false)
- undefined 타입:   선언은 되었지만 값을 할당하지 않은 변수에 암묵적으로 할당되는 값
- null 타입: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값
- Symbol 타입: ES6에서 새롭게 추가된 7번째 타입
- 'NaN'은숫자타입임, 양의무한대,음의무한대와 같이
- 을제외한 모든것은 참조타입(객체타입)
- 연산자(일치/동등 연산자 / 단항 연산자 / 할당 연산자)
- 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산을 수행해 하나의 값을 만든다.
 
- == 동등, 피연산자 같냐? (자동적으로 타입조절)
- ===, 일치 피연산자가 같냐?(타입조절x)
- NaN === NaN (false인 유일한 값) 비교할땐 isNaN 빌트인함수 이용
- 1개의 피연산자를 연산, ++ , --, +,- 부수효과 존재
- 우항의피연산자, 좌항의 변수로 할당  +=, =,-= 등
- 표현식이 아닌 문과 표현식인 문
- 표현식인 문과 표현식이 아닌 문을 구별하기 위한 가장 간단하고 명료한 방법은 변수에 할당해 보는 것
- var x; '변수 선언문' 표현식이 아닌문
- var foo = var x;
- x = 10;  '할당문' 표현식인 문
- var foo = x = 100;
- 함수란 무엇인가
- 어떤 작업을 수행하기 위해 필요한 문들의 집합을 정의한 코드 블록
- -> 재사용및 유지보수 용이를 위해사용
- 원시타입과 참조타입 (불변성과 가변성)
- 변경불가능하면서, 다른변수에 할당하면 원본값이 복사되어 전달되는(pass by value가 일어나는 타입)
- 변경 가능하면서, 다른변수에 할당하면 원본의 참조값이 복사되어 전달되는(pass by reperence가 일어나는타입)
- 상수와구분(변경불가능이 재할당 불가능을 뜻하는것은 아님)
- 함수 선언문과 표현식의 차이는 무엇인가
- 가장큰차이는 변수에 넣을 수 있느냐 없느냐 =값이 되느냐 되지않느냐
- 함수명을 생략할 수 있냐 없냐
- 호이스팅이 발생하냐 하지않느냐
- 콜백이란 무엇이고 어떻게 사용하는 것인가
- 함수에 인수(argument)로 들어가는 '함수', 보조함수라고도 하며 함수에 인수로 들어가 보조역할을 한다
- 중첩함수와의 차이는 교체가능
- 스코프
- 변수는 자신이 선언된 위치에 의해 자신이 유효한 범위, 즉 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정된다

- 변수를 검색할 때 사용되는 규칙
- 블록 스코프
- {} 블록으로 묶은 스코프
- C나 Java 등 대부분의 프로그래밍 언어는 함수 몸체 만이 아니라 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만든다. 
- 이러한 특성을 블록 레벨 스코프(Block level scope)라 한다
- 단 자바스크립트는 , var는 블록스코프를 제공하지 않아서 {}내부에서 변수선언을 하면 전역변수로 동작한다
- 반복문, 조건문등에서 일반적이게 볼 수 있음
- 함수 스코프
- 함수내부의 변수 유효범위, 자바스크립트에서 함수 스코프를 기본적으로 제공
- 스코프 체인란 무엇이고 지역 스코프가 변수를 찾아나가는 과정은?
- 스코프체인이란 부모/자식, 할아버지,부모,자식 등 여러개의 스코프 계층 구조
- 변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.
- 변수를 찾아서 사용을 한다 가정했을시, 먼저 자신의 지역스코프에서 찾아보고 없으면 '바로 상위','부모'스코프를 찾아본후
- 없으면 또 '바로상위'스코프를 찾아봄, 이런식으로 상단으로 상단으로 올라가다가 더이상 올라갈 수 없을시 최종적으로 전역스코프를 찾아본다.
- 동적 스코프 / 정적 스코프 (렉시컬 스코프)
- 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다.(동적)
- 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라 상위 스코프를 결정한다.(정적)
- 다음 코드가 어떻게 동작하고 왜 그렇게 동작하는지? (암묵적 전역변수)
- 변수선언없이 , 할당을 바로했을시 자바스크립트 엔진이 '전역'변수로 x를 선언해서 사용
- 전역변수가 많아지면 많은 문제가 발생할 수 있어서 좋은 것은 아님

## 러버덕 아닌것
- 프로그래밍 (progam + ing) 프로그램을 만드는것.
- 프로그램이란 '순서'
- 컴퓨터에게 시킬 명령의 '순서'를 정해주고 흐름을 제어하는 것
- 단 컴퓨터가 알아들을 수 있게 '문법'에 맞춰야하고 
- 갖춰진 명령들을 알아들 을 수 있게 기계어로 번역하는 것을 '컴파일러','인터프리터'
- 즉 컴파일러 인터프리터는 통역가,번역가이라고 이해
- 자바스크립트란, html을 동적으로 제어하기 위한 '언어'
- 클라이언트단에서 ES+WEB API, 서버단에서 ES+NODE.JS로 구성 ES공통, WEB API와 NODE.JS지원하는 API차이
- 특징:싱글스레드, 비동기, concurrency ,인터프리터 언어, 프로토타입 기반 객체지향 프래그래밍 지원,동적타입 언어
- 변수와 상수의 차이:재할당 할 수 있는가? 순수하게 이차이로만 구분
- 원시 값은 변경 불가능한 값(immutable value)이지만 객체 타입의 값, 즉 객체는 변경 가능한 값(mutable value)
- 여기서 상수와 이뮤터블을 구분하는것이 아님xx  
- 완료 값(Completion value)
- 크롬 개발자 도구에서 표현식이 아닌 문은 언제나 undefined를 출력한다. 이를 완료 값(Completion value)이라 한다. 완료 값은 다른 값과 같이 변수에 할당할 수는 없다.
- falsy값
- false
- undefined
- null
- 0, -0
- NaN
- '' (빈문자열)
- 얕은 복사(shallow copy)와 깊은 복사(deep copy)
- 참조 값을 복사하는 것을 얕은 복사(shallow copy), 원시 값처럼 객체 자체를 복사하여 다시 생성하는 것을 깊은 복사(deep copy)라 한다.
- 전역변수 문제점
- 암묵적결합
- 긴생명주기
- 스코프체인상종점에 존재
- 네임스페이스오염

## Constructor 
- Prototype ~ 면접 질문의 단골
- 객체지향 
- 상속
- 클로저 – 객체지향에서 캡슐화

## 생성자 함수 – 통상적으로 constructor
- 객체를 생성하기 위한 용도로 사용되는 함수 생성자 함수
- 빌트인(네이티브) 생성자 함수 (레퍼 객체) 
- const strObj = new String(‘hi’); - 전역 객체의 메서드
- new 연산자
- {}
- Object (x)
- 생성자 함수(o)
- Object.create()
- var x = 1; 
- var o = {}; 
- 호출하려면 미리 만들어놔야 한다. 
- 생성자 함수는 클래스와 유사하다
```
function Person() {
// 1. 빈 객체를 생성하고 this에 바인딩
this.name = ‘Lee’;
this.sayHello = function () {
  console.log(‘hello ${this.name}!’);
}
// 2. this 를 암묵적 변환
}

const me = new Person();
console.log(me);

Person(); // undefined
new Person(); // 빈 객체 생성 Person {}

function Person(name) {
  // 1. 빈 객체를 생성하고 this에 바인딩
  this.name = name;
  this.sayHello = function () {
    console.log(`hello ${this.name}!`);
  }
  // 2. this 를 암묵적 변환
}
  
const me = new Person('Lee');
console.log(me);
me.sayHello();

const you = new Person('Kim');
you.sayHello();
```

- new.target – ES6 문법, ie에서 지원 안됨, 일종의 안전장치

## 함수와 일급 객체
- 일급 객체

- 함수 객체의 프로퍼티
- 함수 객체 만의 프로퍼티
- 유사 배열 객체 string, arguments

- 함수명. 함수 내부에서 식별 가능한 식별자
- 문법이 난해하면 안하는게 좋다

- Property 접근자 프로퍼티

- 프로토 프로퍼티 -> object property

## 프로토타입
- 자바스크립트가 상속을 구현하는 방식
- 프로토타입 객체는 constructor 라는 빌트인 함수가 있다
- 프로토타입 체인은 상속을 구현하기 위한 매커니즘
- 식별자와 프로토타입은 서로 찾는 곳이 다르다
- 스코프는 상속되는 것 아님
- Object.__proto__
- 프로퍼티를 찾는 매커니즘, 상속 구조
- 식별자 검색
- 프로퍼티 검색
- 클래스 – 문법적 설탕
- 객체는 상태와 동작을 그룹화 한 것.
- 상속 : 상속(inheritance)은 객체지향 프로그래밍의 핵심 개념으로 상위(부모) 객체의 프로퍼티 또는 메소드를 하위(자식) 객체가 상속받아 그대로 사용할 수 있는 것을 말한다
- 자바스크립트는 프로토타입(prototype)을 기반으로 상속을 구현한다
- 프로토타입 체인




